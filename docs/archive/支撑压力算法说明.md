# 支撑压力算法说明

## 一、算法核心思想

支撑压力系统基于以下核心思想：
1. **价格记忆效应**：历史价格水平对当前价格有影响
2. **成交量确认**：高成交量区域形成重要支撑压力位
3. **多维度验证**：结合时间、价格、成交量等多个维度

## 二、主要算法

### 2.1 通达信固定算法

#### 算法原理
基于价格区间的固定比例计算支撑压力位，这是最经典的技术分析方法。

#### 核心公式
```python
def calculate_fixed_sr(high_prices, low_prices):
    # 计算价格区间
    day_high = max(high_prices)
    day_low = min(low_prices)
    price_range = day_high - day_low
    
    # 固定支撑压力位
    fixed_resistance = day_low + price_range * 7/8    # 上轨
    fixed_support = day_low + price_range * 0.5/8     # 下轨
    mid_point = day_low + price_range * 0.5           # 中轴
    
    return {
        'resistance': fixed_resistance,
        'support': fixed_support,
        'mid_point': mid_point
    }
```

#### 算法特点
- **简单有效**：计算简单，逻辑清晰
- **固定比例**：7/8和0.5/8是经验值
- **适用性强**：适用于各种市场环境

### 2.2 动态支撑压力算法

#### 算法原理
通过识别局部极值点，使用聚类算法找到价格聚集的关键区域。

#### 核心步骤
```python
def detect_dynamic_sr(prices, window_size=20, min_touches=3):
    # 1. 识别局部极值点
    peaks, troughs = find_extrema(prices, window_size)
    
    # 2. 合并所有极值点
    all_extrema = merge_extrema(peaks, troughs)
    
    # 3. 价格聚类
    clusters = cluster_price_levels(all_extrema)
    
    # 4. 计算强度
    sr_levels = []
    for cluster in clusters:
        if len(cluster) >= min_touches:
            level = analyze_cluster(cluster, prices)
            sr_levels.append(level)
    
    return sr_levels
```

#### 极值点识别
```python
def find_extrema(prices, window_size):
    peaks = []
    troughs = []
    window = window_size // 2
    
    for i in range(window, len(prices) - window):
        # 检查是否为局部最大值
        if all(prices[i] >= prices[j] for j in range(i-window, i+window+1) if j != i):
            peaks.append(i)
        # 检查是否为局部最小值
        elif all(prices[i] <= prices[j] for j in range(i-window, i+window+1) if j != i):
            troughs.append(i)
    
    return peaks, troughs
```

#### 价格聚类算法
```python
def cluster_price_levels(extrema, tolerance=0.002):
    clusters = {}
    cluster_id = 0
    
    # 按价格排序
    sorted_extrema = sorted(extrema, key=lambda x: x['price'])
    
    for i, point in enumerate(sorted_extrema):
        if i == 0:
            clusters[cluster_id] = [point]
        else:
            # 计算价格差距
            prev_price = sorted_extrema[i-1]['price']
            price_diff = abs(point['price'] - prev_price) / prev_price
            
            # 如果差距小于阈值，加入当前簇
            if price_diff <= tolerance:
                clusters[cluster_id].append(point)
            else:
                # 否则创建新簇
                cluster_id += 1
                clusters[cluster_id] = [point]
    
    return clusters
```

### 2.3 基于成交量的算法

#### 算法原理
成交量是价格运动的"燃料"，高成交量区域往往形成重要的支撑压力位。

#### 核心计算
```python
def calculate_volume_sr(data, length=25):
    high = data['high'].values
    low = data['low'].values
    close = data['close'].values
    volume = data['volume'].values
    
    # 1. 计算成交量百分位
    n_vol = calculate_volume_percentile(volume)
    
    # 2. 计算ATR
    atr = calculate_atr(high, low, close)
    
    # 3. 识别支撑阻力位
    resistance_levels = []
    support_levels = []
    
    for i in range(length, len(data)):
        # 检测阻力位（前高）
        if highest[i-1] == high[i-1] and high[i] < highest[i-1]:
            resistance_levels.append({
                'price': highest[i-1],
                'volume_pct': n_vol[i],
                'band_width': atr[i] * n_vol[i]
            })
        
        # 检测支撑位（前低）
        if lowest[i-1] == low[i-1] and low[i] > lowest[i-1]:
            support_levels.append({
                'price': lowest[i-1],
                'volume_pct': n_vol[i],
                'band_width': atr[i] * n_vol[i]
            })
    
    return resistance_levels, support_levels
```

#### 成交量百分位计算
```python
def calculate_volume_percentile(volumes, lookback=500):
    normalized_volumes = []
    
    for i in range(len(volumes)):
        # 获取回看窗口
        start_idx = max(0, i - lookback + 1)
        window = volumes[start_idx:i+1]
        
        if len(window) > 0:
            # 计算当前成交量在窗口中的百分位
            percentile = (np.sum(window <= volumes[i]) / len(window)) * 100
            normalized_volumes.append(percentile)
        else:
            normalized_volumes.append(50)  # 默认值
    
    return np.array(normalized_volumes)
```

## 三、强度评级算法

### 3.1 评分体系

#### 评分因素及权重
```python
weights = {
    'touches': 0.25,          # 触及次数权重
    'volume': 0.20,           # 成交量权重
    'time_span': 0.15,        # 时间跨度权重
    'bounce_strength': 0.20,  # 反弹强度权重
    'multi_timeframe': 0.10,  # 多周期确认权重
    'recency': 0.10          # 最近触及权重
}
```

#### 综合评分计算
```python
def calculate_comprehensive_score(level, market_data):
    scores = {}
    
    # 1. 触及次数得分
    scores['touches'] = score_touches(level.get('touches', 0))
    
    # 2. 成交量得分
    scores['volume'] = score_volume(level, market_data)
    
    # 3. 时间跨度得分
    scores['time_span'] = score_time_span(level, market_data)
    
    # 4. 反弹强度得分
    scores['bounce_strength'] = score_bounce_strength(level, market_data)
    
    # 5. 多周期确认得分
    scores['multi_timeframe'] = score_multi_timeframe(level)
    
    # 6. 最近触及得分
    scores['recency'] = score_recency(level, market_data)
    
    # 计算加权总分
    total_score = 0
    for factor, score in scores.items():
        weight = weights.get(factor, 0)
        total_score += score * weight
    
    return round(total_score, 1)
```

### 3.2 各项评分函数

#### 触及次数评分
```python
def score_touches(touches):
    if touches <= 0:
        return 0
    elif touches >= 10:
        return 100
    else:
        return touches * 10  # 线性插值
```

#### 成交量评分
```python
def score_volume(level, market_data):
    volume_data = level.get('volume_data', {})
    if not volume_data:
        return 50
    
    level_avg_volume = volume_data.get('average', 0)
    total_avg_volume = market_data.get('average_volume', 1)
    
    if total_avg_volume == 0:
        return 50
    
    volume_ratio = level_avg_volume / total_avg_volume
    
    # 转换为分数
    if volume_ratio >= 2.0:
        return 100
    elif volume_ratio >= 1.5:
        return 80
    elif volume_ratio >= 1.0:
        return 60
    elif volume_ratio >= 0.5:
        return 40
    else:
        return 20
```

#### 时间跨度评分
```python
def score_time_span(level, market_data):
    first_touch_idx = level.get('first_touch_index', 0)
    last_touch_idx = level.get('last_touch_index', 0)
    total_periods = market_data.get('total_periods', 1)
    
    if total_periods == 0:
        return 50
    
    span_ratio = (last_touch_idx - first_touch_idx) / total_periods
    
    # 时间跨度越大，说明该位置越重要
    if span_ratio >= 0.8:
        return 100
    elif span_ratio >= 0.6:
        return 80
    elif span_ratio >= 0.4:
        return 60
    elif span_ratio >= 0.2:
        return 40
    else:
        return 20
```

## 四、算法优化

### 4.1 参数调优

#### 关键参数
```python
# 动态支撑压力参数
WINDOW_SIZE = 20          # 极值点识别窗口
MIN_TOUCHES = 3           # 最小触及次数
PRICE_TOLERANCE = 0.002   # 价格容忍度(0.2%)
LOOKBACK_PERIODS = 100    # 回看周期数

# 成交量支撑压力参数
LENGTH = 25               # 计算周期
RESISTANCE_THRESHOLD = 80 # 阻力位成交量阈值(%)
SUPPORT_THRESHOLD = 80    # 支撑位成交量阈值(%)
BARS_THRESHOLD = 50       # K线着色阈值(%)
```

#### 自适应参数
```python
def adaptive_parameters(volatility, volume_trend):
    # 根据市场波动性调整参数
    if volatility > 0.05:  # 高波动
        price_tolerance = 0.003
        min_touches = 2
    elif volatility < 0.02:  # 低波动
        price_tolerance = 0.001
        min_touches = 4
    else:  # 正常波动
        price_tolerance = 0.002
        min_touches = 3
    
    return {
        'price_tolerance': price_tolerance,
        'min_touches': min_touches
    }
```

### 4.2 算法融合

#### 多算法结合
```python
def combined_sr_analysis(prices, volumes, timestamps):
    # 1. 固定支撑压力
    fixed_levels = calculate_fixed_sr(prices)
    
    # 2. 动态支撑压力
    dynamic_levels = detect_dynamic_sr(prices)
    
    # 3. 成交量支撑压力
    volume_levels = calculate_volume_sr(prices, volumes)
    
    # 4. 融合结果
    combined_levels = merge_sr_levels(
        fixed_levels, 
        dynamic_levels, 
        volume_levels
    )
    
    # 5. 强度评级
    rated_levels = rate_levels(combined_levels, {
        'prices': prices,
        'volumes': volumes,
        'total_periods': len(prices)
    })
    
    return rated_levels
```

#### 结果融合策略
```python
def merge_sr_levels(fixed_levels, dynamic_levels, volume_levels):
    merged = []
    
    # 添加固定支撑压力位
    for level in fixed_levels:
        merged.append({
            'price': level['price'],
            'type': level['type'],
            'strength': 80,  # 固定强度
            'source': 'fixed',
            'description': level['description']
        })
    
    # 添加动态支撑压力位
    for level in dynamic_levels:
        if level['strength'] > 50:  # 只保留强度较高的
            merged.append({
                'price': level['price'],
                'type': level['type'],
                'strength': level['strength'],
                'source': 'dynamic',
                'touches': level['touches']
            })
    
    # 添加成交量支撑压力位
    for level in volume_levels:
        if level['volume_pct'] > 70:  # 只保留高成交量确认的
            merged.append({
                'price': level['price'],
                'type': level['type'],
                'strength': level['volume_pct'],
                'source': 'volume',
                'volume_pct': level['volume_pct']
            })
    
    # 合并相近的价位
    merged = merge_nearby_levels(merged, threshold=0.002)
    
    return merged
```

## 五、性能优化

### 5.1 计算优化

#### 向量化计算
```python
import numpy as np

def vectorized_extrema_detection(prices, window_size):
    """向量化的极值点检测"""
    prices = np.array(prices)
    n = len(prices)
    
    # 使用numpy的滑动窗口
    peaks = []
    troughs = []
    
    for i in range(window_size//2, n - window_size//2):
        window = prices[i-window_size//2:i+window_size//2+1]
        
        if prices[i] == np.max(window):
            peaks.append(i)
        elif prices[i] == np.min(window):
            troughs.append(i)
    
    return peaks, troughs
```

#### 缓存机制
```python
from functools import lru_cache

@lru_cache(maxsize=1000)
def cached_volume_percentile(volume_tuple, lookback):
    """缓存成交量百分位计算"""
    volumes = np.array(volume_tuple)
    return calculate_volume_percentile(volumes, lookback)
```

### 5.2 内存优化

#### 数据压缩
```python
def compress_sr_data(levels):
    """压缩支撑压力数据"""
    compressed = []
    
    for level in levels:
        compressed.append({
            'p': round(level['price'], 2),  # 价格保留2位小数
            't': level['type'][:1],         # 类型简化为单字符
            's': int(level['strength']),    # 强度转为整数
            'd': level.get('description', '')[:20]  # 描述截断
        })
    
    return compressed
```

## 六、总结

支撑压力算法系统通过多种方法的结合，实现了对关键价位的准确识别和强度评级。系统具有以下特点：

1. **算法多样性**：结合固定、动态、成交量等多种算法
2. **评分科学性**：基于多维度因素的综合评分体系
3. **实时性**：支持实时计算和动态更新
4. **可扩展性**：模块化设计，易于扩展新算法
5. **性能优化**：采用向量化计算和缓存机制

该系统为交易决策提供了科学的技术分析工具，但需要注意结合市场环境和其他技术指标进行综合判断。
