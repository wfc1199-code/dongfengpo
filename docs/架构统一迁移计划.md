# ä¸œé£ç ´ - æ¶æ„ç»Ÿä¸€è¿ç§»è®¡åˆ’ï¼ˆ3-6ä¸ªæœˆï¼‰

## ğŸ“‹ æ€»ä½“ç›®æ ‡

å°†å½“å‰Legacyå•ä½“ç³»ç»Ÿé€æ­¥è¿ç§»åˆ°å¾®æœåŠ¡æ¶æ„ï¼Œå»ºç«‹ç­–ç•¥æ’ä»¶ç”Ÿæ€ï¼Œå®ç°åˆ†å¸ƒå¼éƒ¨ç½²ï¼Œå¹¶å¢å¼ºæœºå™¨å­¦ä¹ èƒ½åŠ›ã€‚

---

## Phase 1: æ¶æ„ç»Ÿä¸€ - åºŸå¼ƒLegacyï¼Œå…¨é¢è¿ç§»å¾®æœåŠ¡ï¼ˆMonth 1-2ï¼‰

### 1.1 ä¾èµ–å…³ç³»è¯„ä¼° âœ…

#### Legacyç³»ç»Ÿæ ¸å¿ƒä¾èµ–åˆ†æ

**main.py æ ¸å¿ƒå¯¼å…¥æ¨¡å—ï¼š**
- `core.data_sources.StockDataManager` - æ•°æ®ç®¡ç†å™¨
- `core.anomaly_detection.StockAnalysisEngine` - å¼‚åŠ¨æ£€æµ‹å¼•æ“
- `core.cache_manager` - ç¼“å­˜ç®¡ç†
- `core.optimized_algorithms` - ä¼˜åŒ–ç®—æ³•
- `core.monitoring` - ç³»ç»Ÿç›‘æ§
- `core.security` - å®‰å…¨ä¸­é—´ä»¶

**APIè·¯ç”±æ¨¡å—ï¼ˆ18ä¸ªï¼‰ï¼š**
1. `anomaly_routes` - å¼‚åŠ¨æ£€æµ‹è·¯ç”±
2. `limit_up_routes` - æ¶¨åœé¢„æµ‹è·¯ç”±
3. `time_segmented_predictions` - æ—¶é—´åˆ†æ®µé¢„æµ‹
4. `real_limit_up_data` - å®æ—¶æ¶¨åœæ•°æ®
5. `real_time_segmented_data` - å®æ—¶åˆ†æ®µæ•°æ®
6. `version_routes` - ç‰ˆæœ¬ç®¡ç†
7. `transaction_routes` - æˆäº¤åˆ†æ
8. `support_resistance_tdx` - æ”¯æ’‘é˜»åŠ›
9. `market_behavior_routes` - ä¸»åŠ›è¡Œä¸ºåˆ†æ
10. `market_scanner` - å…¨å¸‚åœºæ‰«æ
11. `market_scanner_routes` - å¸‚åœºæ‰«æå™¨
12. `version_api` - ç‰ˆæœ¬API
13. `smart_selection_routes` - æ™ºèƒ½é€‰è‚¡
14. `stock_pool_routes` - è‚¡ç¥¨æ± ç®¡ç†
15. `market_anomaly_routes` - å¸‚åœºå¼‚åŠ¨æ‰«æ
16. `limit_up_tracker` - æ¶¨åœè¿½è¸ª
17. `quick_prediction_routes` - å¿«é€Ÿé¢„æµ‹
18. `robust_limit_up_system` - ç¨³å®šæ¶¨åœç³»ç»Ÿ

**ä¾èµ–å…³ç³»å›¾ï¼š**
```
FastAPI Main App (main.py)
    â”œâ”€â”€ Core Modules
    â”‚   â”œâ”€â”€ StockDataManager (æ•°æ®æº)
    â”‚   â”œâ”€â”€ StockAnalysisEngine (å¼‚åŠ¨åˆ†æ)
    â”‚   â”œâ”€â”€ cache_manager (ç¼“å­˜)
    â”‚   â”œâ”€â”€ optimized_algorithms (ç®—æ³•)
    â”‚   â”œâ”€â”€ monitoring (ç›‘æ§)
    â”‚   â””â”€â”€ security (å®‰å…¨)
    â””â”€â”€ 18 API Routers
        â”œâ”€â”€ å¼‚åŠ¨æ£€æµ‹ç±» (5ä¸ª)
        â”œâ”€â”€ æ¶¨åœé¢„æµ‹ç±» (5ä¸ª)
        â”œâ”€â”€ æŠ€æœ¯åˆ†æç±» (3ä¸ª)
        â”œâ”€â”€ å¸‚åœºæ‰«æç±» (3ä¸ª)
        â””â”€â”€ ç®¡ç†ç±» (2ä¸ª)
```

### 1.2 è¿ç§»è·¯çº¿å›¾

#### é˜¶æ®µ1: APIç½‘å…³å±‚ï¼ˆWeek 1-2ï¼‰

**ç›®æ ‡ï¼š** å»ºç«‹ç»Ÿä¸€APIç½‘å…³ï¼Œå®ç°Legacyä¸æ–°æœåŠ¡å¹¶å­˜

**ä»»åŠ¡ï¼š**
- [ ] è®¾è®¡APIç½‘å…³æ¶æ„ï¼ˆKong / Nginx / Traefikï¼‰
- [ ] å®šä¹‰ç»Ÿä¸€APIç‰ˆæœ¬è·¯ç”±è§„åˆ™ (`/api/v1/legacy/*`, `/api/v2/pipeline/*`)
- [ ] å®ç°è¯·æ±‚è½¬å‘ä¸è´Ÿè½½å‡è¡¡
- [ ] é…ç½®CORSã€è®¤è¯ã€é™æµä¸­é—´ä»¶
- [ ] éƒ¨ç½²ç½‘å…³æœåŠ¡ï¼ˆç«¯å£8080ï¼‰

**æŠ€æœ¯é€‰å‹ï¼š**
```yaml
# Kong API Gateway æ¨èé…ç½®
services:
  - name: legacy-backend
    url: http://localhost:9000
    routes:
      - paths: ["/api/v1/*"]

  - name: signal-api
    url: http://localhost:8001
    routes:
      - paths: ["/api/v2/signals/*"]

  - name: signal-streamer
    url: http://localhost:8002
    routes:
      - paths: ["/api/v2/ws/*"]
```

#### é˜¶æ®µ2: æ•°æ®å±‚è¿ç§»ï¼ˆWeek 3-4ï¼‰

**ç›®æ ‡ï¼š** å°†æ•°æ®è·å–é€»è¾‘è¿ç§»åˆ°collector-gateway

**è¿ç§»è®¡åˆ’ï¼š**
1. **StockDataManager â†’ collector-gateway**
   - è…¾è®¯è´¢ç»API â†’ collectoræ’ä»¶
   - ä¸œæ–¹è´¢å¯ŒAPI â†’ collectoræ’ä»¶
   - æ–°æµªè´¢ç»API â†’ collectoræ’ä»¶
   - ç»Ÿä¸€è¾“å‡ºåˆ° `dfp:raw_ticks`

2. **ç¼“å­˜å±‚ç»Ÿä¸€**
   - Legacy `cache_manager` â†’ Redisç»Ÿä¸€ç¼“å­˜
   - æ–‡ä»¶ç¼“å­˜ â†’ RedisæŒä¹…åŒ–

3. **æ•°æ®æ¸…æ´—**
   - å°† `core.data_sources` çš„æ•°æ®å¤„ç†é€»è¾‘ â†’ `data-cleaner`

**éªŒè¯æ ‡å‡†ï¼š**
- [ ] æ–°æ—§ç³»ç»Ÿæ•°æ®ä¸€è‡´æ€§>99%
- [ ] APIå“åº”æ—¶é—´ä¸å¢åŠ 
- [ ] ç¼“å­˜å‘½ä¸­ç‡>80%

#### é˜¶æ®µ3: ä¸šåŠ¡é€»è¾‘è¿ç§»ï¼ˆWeek 5-6ï¼‰

**ç›®æ ‡ï¼š** å°†å¼‚åŠ¨æ£€æµ‹ã€æ¶¨åœé¢„æµ‹è¿ç§»åˆ°strategy-engine

**è¿ç§»æ˜ å°„ï¼š**
| Legacyæ¨¡å— | æ–°æœåŠ¡ | åŠŸèƒ½ |
|-----------|--------|------|
| `core.anomaly_detection` | `strategy-engine` | å¼‚åŠ¨æ£€æµ‹ç­–ç•¥ |
| `api.limit_up_routes` | `strategy-engine` | æ¶¨åœé¢„æµ‹ç­–ç•¥ |
| `api.market_scanner` | `opportunity-aggregator` | å¸‚åœºæ‰«æèšåˆ |
| `api.market_behavior_routes` | `strategy-engine` | ä¸»åŠ›è¡Œä¸ºç­–ç•¥ |

**ç­–ç•¥æ’ä»¶åŒ–æ”¹é€ ï¼š**
```python
# ç¤ºä¾‹ï¼šå°†å¼‚åŠ¨æ£€æµ‹æ”¹é€ ä¸ºç­–ç•¥æ’ä»¶
# legacy: core/anomaly_detection.py â†’ strategy: anomaly_strategy.py

class AnomalyDetectionStrategy(BaseStrategy):
    name = "anomaly_detection"
    version = "1.0"

    async def analyze(self, features: dict) -> Signal:
        # åŸå¼‚åŠ¨æ£€æµ‹é€»è¾‘
        if features['price_change_rate'] > 0.03:
            return Signal(
                type='anomaly',
                confidence=0.85,
                reason='æ€¥é€Ÿæ‹‰å‡'
            )
```

#### é˜¶æ®µ4: å‰ç«¯åˆ‡æ¢ï¼ˆWeek 7-8ï¼‰

**ç›®æ ‡ï¼š** å‰ç«¯ä»Legacy APIåˆ‡æ¢åˆ°æ–°æœåŠ¡

**åˆ‡æ¢ç­–ç•¥ï¼š**
1. **ç°åº¦å‘å¸ƒï¼š** 10% â†’ 50% â†’ 100%
2. **ABæµ‹è¯•ï¼š** å¯¹æ¯”æ–°æ—§ç³»ç»Ÿæ€§èƒ½
3. **å›é€€æœºåˆ¶ï¼š** å‡ºé—®é¢˜ç«‹å³åˆ‡å›Legacy

**å‰ç«¯APIè°ƒæ•´ï¼š**
```typescript
// æ—§API: /api/anomaly/detect-legacy
// æ–°API: /api/v2/signals/opportunities

// services/backend.service.ts
const API_BASE = process.env.REACT_APP_USE_V2
  ? 'http://localhost:8080/api/v2'  // æ–°ç½‘å…³
  : 'http://localhost:9000/api';     // Legacy
```

### 1.3 éªŒæ”¶æ ‡å‡†

- [ ] æ–°ç³»ç»ŸåŠŸèƒ½å®Œæ•´è¦†ç›–Legacy
- [ ] APIå“åº”æ—¶é—´ < Legacyçš„120%
- [ ] ç¨³å®šè¿è¡Œ2å‘¨æ— é‡å¤§bug
- [ ] å‰ç«¯å®Œå…¨åˆ‡æ¢åˆ°æ–°API
- [ ] Legacyç³»ç»Ÿæ ‡è®°ä¸ºDeprecated

---

## Phase 2: ç­–ç•¥å¸‚åœº - å»ºç«‹æ’ä»¶ç”Ÿæ€ï¼ˆMonth 2-3ï¼‰

### 2.1 ç­–ç•¥æ’ä»¶æ¥å£è§„èŒƒ

#### ç»Ÿä¸€ç­–ç•¥æ¥å£å®šä¹‰

```python
# libs/strategy-sdk/base_strategy.py

from abc import ABC, abstractmethod
from typing import Dict, List, Optional
from dataclasses import dataclass
from enum import Enum

class SignalType(Enum):
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"
    ANOMALY = "anomaly"
    WARNING = "warning"

@dataclass
class Signal:
    """ç­–ç•¥ä¿¡å·"""
    type: SignalType
    stock_code: str
    confidence: float  # 0-1
    timestamp: int
    reason: str
    metadata: Dict

class BaseStrategy(ABC):
    """ç­–ç•¥åŸºç±»"""

    # ç­–ç•¥å…ƒæ•°æ®
    name: str
    version: str
    author: str
    description: str

    # ä¾èµ–ç‰¹å¾
    required_features: List[str] = []

    @abstractmethod
    async def initialize(self, config: Dict):
        """åˆå§‹åŒ–ç­–ç•¥"""
        pass

    @abstractmethod
    async def analyze(self, features: Dict) -> List[Signal]:
        """åˆ†æå¹¶ç”Ÿæˆä¿¡å·"""
        pass

    @abstractmethod
    async def on_market_open(self):
        """å¼€ç›˜å›è°ƒ"""
        pass

    @abstractmethod
    async def on_market_close(self):
        """æ”¶ç›˜å›è°ƒ"""
        pass
```

#### ç­–ç•¥é…ç½®è§„èŒƒ

```yaml
# strategies/rapid_rise/strategy.yaml
name: rapid_rise
version: 1.2.0
author: dongfengpo_team
description: å¿«é€Ÿæ‹‰å‡å¼‚åŠ¨æ£€æµ‹ç­–ç•¥

dependencies:
  - price_change_rate
  - volume_ratio
  - money_flow_5min

parameters:
  price_threshold: 0.03      # æ¶¨å¹…é˜ˆå€¼3%
  volume_threshold: 2.0      # é‡æ¯”é˜ˆå€¼2å€
  time_window: 300           # æ—¶é—´çª—å£5åˆ†é’Ÿ
  confidence_base: 0.8       # åŸºç¡€ç½®ä¿¡åº¦

risk_controls:
  max_signals_per_minute: 10
  min_confidence: 0.6
  blacklist_sectors: ["STè‚¡", "é€€å¸‚è‚¡"]

backtest:
  start_date: 2024-01-01
  end_date: 2024-12-31
  initial_capital: 1000000
  metrics:
    sharpe_ratio: 1.85
    win_rate: 0.68
    max_drawdown: 0.12
```

### 2.2 ç­–ç•¥ä»“åº“ä¸ç‰ˆæœ¬ç®¡ç†

#### ç›®å½•ç»“æ„

```
strategies/
â”œâ”€â”€ README.md
â”œâ”€â”€ official/              # å®˜æ–¹ç­–ç•¥
â”‚   â”œâ”€â”€ rapid_rise/
â”‚   â”‚   â”œâ”€â”€ strategy.yaml
â”‚   â”‚   â”œâ”€â”€ strategy.py
â”‚   â”‚   â”œâ”€â”€ backtest_report.json
â”‚   â”‚   â””â”€â”€ README.md
â”‚   â”œâ”€â”€ limit_up_tracker/
â”‚   â”œâ”€â”€ support_resistance/
â”‚   â””â”€â”€ money_flow/
â”œâ”€â”€ community/             # ç¤¾åŒºç­–ç•¥
â”‚   â”œâ”€â”€ user1_strategy/
â”‚   â””â”€â”€ user2_strategy/
â””â”€â”€ private/               # ç§æœ‰ç­–ç•¥ï¼ˆgitignoreï¼‰
    â””â”€â”€ my_secret_strategy/
```

#### ç­–ç•¥æ³¨å†Œä¸å‘ç°

```python
# services/strategy-engine/strategy_registry.py

class StrategyRegistry:
    """ç­–ç•¥æ³¨å†Œè¡¨"""

    def __init__(self):
        self.strategies: Dict[str, BaseStrategy] = {}
        self.metadata: Dict[str, Dict] = {}

    async def register(self, strategy_path: str):
        """æ³¨å†Œç­–ç•¥"""
        # 1. åŠ è½½strategy.yaml
        config = load_yaml(f"{strategy_path}/strategy.yaml")

        # 2. åŠ¨æ€å¯¼å…¥strategy.py
        module = import_module(f"{strategy_path}/strategy.py")
        StrategyClass = getattr(module, config['class_name'])

        # 3. å®ä¾‹åŒ–å¹¶åˆå§‹åŒ–
        strategy = StrategyClass()
        await strategy.initialize(config['parameters'])

        # 4. æ³¨å†Œåˆ°è¡¨
        self.strategies[config['name']] = strategy
        self.metadata[config['name']] = config

        logger.info(f"Registered strategy: {config['name']} v{config['version']}")

    async def discover_strategies(self, search_paths: List[str]):
        """è‡ªåŠ¨å‘ç°å¹¶æ³¨å†Œæ‰€æœ‰ç­–ç•¥"""
        for path in search_paths:
            for strategy_dir in Path(path).iterdir():
                if (strategy_dir / "strategy.yaml").exists():
                    await self.register(str(strategy_dir))
```

### 2.3 ç­–ç•¥å›æµ‹ä¸è¯„ä¼°ç³»ç»Ÿ

#### å›æµ‹å¼•æ“

```python
# services/backtest-service/backtest_engine.py

class BacktestEngine:
    """ç­–ç•¥å›æµ‹å¼•æ“"""

    async def run_backtest(
        self,
        strategy: BaseStrategy,
        start_date: str,
        end_date: str,
        initial_capital: float = 1000000
    ) -> BacktestReport:
        """è¿è¡Œå›æµ‹"""

        # 1. åŠ è½½å†å²æ•°æ®
        data = await self.load_historical_data(start_date, end_date)

        # 2. åˆå§‹åŒ–è´¦æˆ·
        portfolio = Portfolio(initial_capital)

        # 3. é€æ—¥å›æ”¾
        signals_history = []
        for date, tick_data in data.items():
            # è®¡ç®—ç‰¹å¾
            features = await self.compute_features(tick_data)

            # ç­–ç•¥åˆ†æ
            signals = await strategy.analyze(features)
            signals_history.extend(signals)

            # æ‰§è¡Œäº¤æ˜“
            for signal in signals:
                if signal.type == SignalType.BUY:
                    portfolio.buy(signal.stock_code, price, quantity)
                elif signal.type == SignalType.SELL:
                    portfolio.sell(signal.stock_code, price, quantity)

        # 4. è®¡ç®—æŒ‡æ ‡
        return BacktestReport(
            total_return=portfolio.total_return(),
            sharpe_ratio=self.calc_sharpe(portfolio),
            max_drawdown=self.calc_max_drawdown(portfolio),
            win_rate=self.calc_win_rate(signals_history),
            trades=portfolio.trades,
            equity_curve=portfolio.equity_curve
        )
```

#### ç­–ç•¥è¯„ä¼°API

```python
# services/backtest-service/main.py

@app.post("/api/backtest/run")
async def run_backtest(request: BacktestRequest):
    """è¿è¡Œç­–ç•¥å›æµ‹"""
    strategy = strategy_registry.get(request.strategy_name)

    report = await backtest_engine.run_backtest(
        strategy=strategy,
        start_date=request.start_date,
        end_date=request.end_date,
        initial_capital=request.initial_capital
    )

    return {
        "status": "success",
        "report": report.to_dict(),
        "visualizations": {
            "equity_curve": generate_equity_chart(report),
            "drawdown": generate_drawdown_chart(report)
        }
    }

@app.get("/api/strategies/leaderboard")
async def get_strategy_leaderboard():
    """ç­–ç•¥æ’è¡Œæ¦œ"""
    strategies = await db.get_all_strategies()

    # æŒ‰å¤æ™®æ¯”ç‡æ’åº
    leaderboard = sorted(
        strategies,
        key=lambda s: s['backtest_metrics']['sharpe_ratio'],
        reverse=True
    )

    return {"strategies": leaderboard[:50]}
```

---

## Phase 3: åˆ†å¸ƒå¼éƒ¨ç½² - å¤šèŠ‚ç‚¹è´Ÿè½½å‡è¡¡ï¼ˆMonth 3-4ï¼‰

### 3.1 æœåŠ¡æ³¨å†Œä¸å‘ç°

#### æŠ€æœ¯é€‰å‹ï¼šConsul

```yaml
# docker-compose.consul.yml
version: '3.8'

services:
  consul-server:
    image: consul:1.15
    ports:
      - "8500:8500"
      - "8600:8600/udp"
    command: agent -server -ui -bootstrap-expect=1 -client=0.0.0.0
    volumes:
      - consul-data:/consul/data

  # æœåŠ¡å®ä¾‹è‡ªåŠ¨æ³¨å†Œ
  signal-api-1:
    image: dongfengpo/signal-api:latest
    environment:
      - CONSUL_URL=http://consul-server:8500
      - SERVICE_NAME=signal-api
      - SERVICE_PORT=8001
    depends_on:
      - consul-server
```

#### æœåŠ¡æ³¨å†Œå®ç°

```python
# libs/service-discovery/consul_client.py

import consul
from typing import Dict, List

class ServiceDiscovery:
    def __init__(self, consul_url: str = "http://localhost:8500"):
        self.consul = consul.Consul(host=consul_url)

    async def register_service(
        self,
        name: str,
        port: int,
        tags: List[str] = None,
        health_check_url: str = None
    ):
        """æ³¨å†ŒæœåŠ¡åˆ°Consul"""
        self.consul.agent.service.register(
            name=name,
            service_id=f"{name}-{port}",
            address="localhost",
            port=port,
            tags=tags or [],
            check=consul.Check.http(
                url=health_check_url or f"http://localhost:{port}/health",
                interval="10s",
                timeout="5s"
            )
        )
        logger.info(f"Service registered: {name} on port {port}")

    async def discover_service(self, name: str) -> List[Dict]:
        """å‘ç°æœåŠ¡å®ä¾‹"""
        _, services = self.consul.health.service(name, passing=True)

        instances = [
            {
                "address": s['Service']['Address'],
                "port": s['Service']['Port'],
                "tags": s['Service']['Tags']
            }
            for s in services
        ]

        return instances
```

### 3.2 è´Ÿè½½å‡è¡¡ä¸æ•…éšœè½¬ç§»

#### Nginxé…ç½®

```nginx
# nginx.conf

upstream signal_api_cluster {
    least_conn;  # æœ€å°‘è¿æ¥ç®—æ³•

    server signal-api-1:8001 max_fails=3 fail_timeout=30s;
    server signal-api-2:8001 max_fails=3 fail_timeout=30s;
    server signal-api-3:8001 max_fails=3 fail_timeout=30s;

    # å¥åº·æ£€æŸ¥
    check interval=5000 rise=2 fall=3 timeout=1000;
}

upstream strategy_engine_cluster {
    ip_hash;  # ä¼šè¯ä¿æŒ

    server strategy-engine-1:8003;
    server strategy-engine-2:8003;
}

server {
    listen 8080;

    location /api/v2/signals/ {
        proxy_pass http://signal_api_cluster;
        proxy_next_upstream error timeout http_500 http_502 http_503;
    }

    location /api/v2/strategies/ {
        proxy_pass http://strategy_engine_cluster;
    }
}
```

#### å®¢æˆ·ç«¯è´Ÿè½½å‡è¡¡ï¼ˆPythonï¼‰

```python
# libs/load-balancer/round_robin.py

import random
from typing import List, Dict

class LoadBalancer:
    def __init__(self, service_discovery: ServiceDiscovery):
        self.sd = service_discovery
        self.current_index = {}

    async def get_instance(self, service_name: str, strategy: str = "round_robin"):
        """è·å–æœåŠ¡å®ä¾‹"""
        instances = await self.sd.discover_service(service_name)

        if not instances:
            raise ServiceUnavailableError(f"No healthy instance for {service_name}")

        if strategy == "round_robin":
            return self._round_robin(service_name, instances)
        elif strategy == "random":
            return random.choice(instances)
        elif strategy == "least_conn":
            return self._least_conn(instances)

    def _round_robin(self, service_name: str, instances: List[Dict]):
        if service_name not in self.current_index:
            self.current_index[service_name] = 0

        idx = self.current_index[service_name]
        instance = instances[idx % len(instances)]
        self.current_index[service_name] += 1

        return instance
```

### 3.3 é«˜å¯ç”¨éƒ¨ç½²æ¶æ„

```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   ç”¨æˆ·è¯·æ±‚   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                    â”‚  Nginx LB   â”‚ (2èŠ‚ç‚¹ HA)
                    â”‚  + Keepalivedâ”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                â”‚                â”‚
    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
    â”‚  API GW 1 â”‚    â”‚  API GW 2 â”‚    â”‚  API GW 3 â”‚
    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
          â”‚                â”‚                â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                    â”‚   Consul    â”‚ (æœåŠ¡å‘ç°)
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚                â”‚                â”‚
    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”
    â”‚  Signal   â”‚    â”‚ Strategy  â”‚    â”‚Opportunityâ”‚
    â”‚  API x3   â”‚    â”‚ Engine x3 â”‚    â”‚  Agg x2   â”‚
    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”˜
          â”‚                â”‚                â”‚
          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                    â”‚Redis Clusterâ”‚ (3ä¸»3ä»)
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Phase 4: æœºå™¨å­¦ä¹ å¢å¼º - æ·±åº¦å­¦ä¹ ä¼˜åŒ–ï¼ˆMonth 4-6ï¼‰

### 4.1 æ·±åº¦å­¦ä¹ å¼‚åŠ¨æ£€æµ‹æ¨¡å‹

#### æ¨¡å‹æ¶æ„ï¼šTransformer + LSTM

```python
# services/ml-model-service/models/anomaly_detector.py

import torch
import torch.nn as nn

class StockAnomalyTransformer(nn.Module):
    """è‚¡ç¥¨å¼‚åŠ¨æ£€æµ‹Transformeræ¨¡å‹"""

    def __init__(
        self,
        feature_dim: int = 50,
        d_model: int = 128,
        nhead: int = 8,
        num_layers: int = 4,
        dropout: float = 0.1
    ):
        super().__init__()

        # è¾“å…¥åµŒå…¥
        self.embedding = nn.Linear(feature_dim, d_model)

        # ä½ç½®ç¼–ç 
        self.pos_encoder = PositionalEncoding(d_model, dropout)

        # Transformerç¼–ç å™¨
        encoder_layer = nn.TransformerEncoderLayer(
            d_model=d_model,
            nhead=nhead,
            dim_feedforward=512,
            dropout=dropout,
            batch_first=True
        )
        self.transformer = nn.TransformerEncoder(encoder_layer, num_layers)

        # LSTMå±‚ï¼ˆæ•æ‰é•¿æœŸä¾èµ–ï¼‰
        self.lstm = nn.LSTM(
            input_size=d_model,
            hidden_size=64,
            num_layers=2,
            batch_first=True,
            dropout=dropout
        )

        # åˆ†ç±»å¤´
        self.classifier = nn.Sequential(
            nn.Linear(64, 32),
            nn.ReLU(),
            nn.Dropout(dropout),
            nn.Linear(32, 5)  # 5ç±»ï¼šæ­£å¸¸/è½»åº¦/ä¸­åº¦/é‡åº¦/æ¶¨åœ
        )

        # ç½®ä¿¡åº¦é¢„æµ‹
        self.confidence_head = nn.Sequential(
            nn.Linear(64, 16),
            nn.ReLU(),
            nn.Linear(16, 1),
            nn.Sigmoid()
        )

    def forward(self, x, mask=None):
        """
        Args:
            x: (batch, seq_len, feature_dim) æ—¶åºç‰¹å¾
            mask: (batch, seq_len) æ©ç 
        Returns:
            class_logits: (batch, 5) åˆ†ç±»ç»“æœ
            confidence: (batch, 1) ç½®ä¿¡åº¦
        """
        # åµŒå…¥
        x = self.embedding(x)  # (batch, seq_len, d_model)
        x = self.pos_encoder(x)

        # Transformerç¼–ç 
        x = self.transformer(x, src_key_padding_mask=mask)

        # LSTM
        lstm_out, (h_n, c_n) = self.lstm(x)
        last_hidden = h_n[-1]  # (batch, 64)

        # åˆ†ç±»
        class_logits = self.classifier(last_hidden)
        confidence = self.confidence_head(last_hidden)

        return class_logits, confidence
```

#### è®­ç»ƒæ•°æ®å‡†å¤‡

```python
# services/ml-model-service/data/dataset.py

class StockTimeSeriesDataset(torch.utils.data.Dataset):
    """è‚¡ç¥¨æ—¶åºæ•°æ®é›†"""

    def __init__(
        self,
        data_path: str,
        seq_len: int = 60,  # 60ä¸ªæ—¶é—´ç‚¹
        features: List[str] = None
    ):
        self.seq_len = seq_len
        self.features = features or [
            'price', 'volume', 'amount', 'turnover_rate',
            'ma5', 'ma10', 'ma20', 'ma60',
            'volume_ratio', 'money_flow_5min', 'bid_ask_ratio',
            # ... å…±50ä¸ªç‰¹å¾
        ]

        # åŠ è½½æ•°æ®
        self.data = pd.read_parquet(data_path)

        # æ ‡æ³¨å¼‚åŠ¨ç±»å‹
        self.labels = self._label_anomalies()

    def _label_anomalies(self):
        """æ ‡æ³¨å¼‚åŠ¨ç±»å‹"""
        labels = []
        for idx in range(len(self.data)):
            # å‘åçœ‹5åˆ†é’Ÿ
            future_price = self.data.iloc[idx+5]['price'] if idx+5 < len(self.data) else None
            current_price = self.data.iloc[idx]['price']

            if future_price:
                change = (future_price - current_price) / current_price
                if change > 0.03:
                    labels.append(3)  # é‡åº¦å¼‚åŠ¨
                elif change > 0.02:
                    labels.append(2)  # ä¸­åº¦å¼‚åŠ¨
                elif change > 0.01:
                    labels.append(1)  # è½»åº¦å¼‚åŠ¨
                else:
                    labels.append(0)  # æ­£å¸¸
            else:
                labels.append(0)

        return labels

    def __getitem__(self, idx):
        # è·å–æ—¶åºçª—å£
        start = max(0, idx - self.seq_len + 1)
        seq = self.data.iloc[start:idx+1][self.features].values

        # å¡«å……
        if len(seq) < self.seq_len:
            pad = np.zeros((self.seq_len - len(seq), len(self.features)))
            seq = np.vstack([pad, seq])

        return {
            'features': torch.FloatTensor(seq),
            'label': self.labels[idx],
            'mask': torch.ones(self.seq_len) if len(seq) == self.seq_len else None
        }
```

### 4.2 æ¨¡å‹è®­ç»ƒä¸éƒ¨ç½²

#### è®­ç»ƒè„šæœ¬

```python
# services/ml-model-service/train.py

import torch
from torch.utils.data import DataLoader
from transformers import get_cosine_schedule_with_warmup

def train():
    # æ•°æ®
    train_dataset = StockTimeSeriesDataset('data/train.parquet')
    val_dataset = StockTimeSeriesDataset('data/val.parquet')

    train_loader = DataLoader(train_dataset, batch_size=64, shuffle=True)
    val_loader = DataLoader(val_dataset, batch_size=64)

    # æ¨¡å‹
    model = StockAnomalyTransformer().cuda()

    # ä¼˜åŒ–å™¨
    optimizer = torch.optim.AdamW(model.parameters(), lr=1e-4, weight_decay=0.01)
    scheduler = get_cosine_schedule_with_warmup(
        optimizer,
        num_warmup_steps=500,
        num_training_steps=len(train_loader) * 50
    )

    # æŸå¤±å‡½æ•°
    criterion = nn.CrossEntropyLoss()

    # è®­ç»ƒå¾ªç¯
    for epoch in range(50):
        model.train()
        for batch in train_loader:
            features = batch['features'].cuda()
            labels = batch['label'].cuda()

            class_logits, confidence = model(features)
            loss = criterion(class_logits, labels)

            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            scheduler.step()

        # éªŒè¯
        val_acc = evaluate(model, val_loader)
        print(f"Epoch {epoch}: Val Acc = {val_acc:.4f}")

        # ä¿å­˜æœ€ä½³æ¨¡å‹
        torch.save(model.state_dict(), f'checkpoints/model_epoch_{epoch}.pt')
```

#### æ¨¡å‹æ¨ç†æœåŠ¡

```python
# services/ml-model-service/main.py

from fastapi import FastAPI
import torch

app = FastAPI()

# åŠ è½½æ¨¡å‹
model = StockAnomalyTransformer()
model.load_state_dict(torch.load('checkpoints/best_model.pt'))
model.eval()
model.cuda()

@app.post("/api/ml/predict")
async def predict_anomaly(request: PredictRequest):
    """å®æ—¶å¼‚åŠ¨é¢„æµ‹"""
    # å‡†å¤‡ç‰¹å¾
    features = torch.FloatTensor(request.features).unsqueeze(0).cuda()

    # æ¨ç†
    with torch.no_grad():
        class_logits, confidence = model(features)
        pred_class = torch.argmax(class_logits, dim=-1).item()
        pred_conf = confidence.item()

    anomaly_types = ['æ­£å¸¸', 'è½»åº¦å¼‚åŠ¨', 'ä¸­åº¦å¼‚åŠ¨', 'é‡åº¦å¼‚åŠ¨', 'æ¶¨åœ']

    return {
        "anomaly_type": anomaly_types[pred_class],
        "confidence": pred_conf,
        "class_probabilities": torch.softmax(class_logits, dim=-1).tolist()
    }
```

### 4.3 åœ¨çº¿å­¦ä¹ ä¸æ¨¡å‹æ›´æ–°

```python
# services/ml-model-service/online_learning.py

class OnlineLearner:
    """åœ¨çº¿å­¦ä¹ å™¨"""

    async def collect_feedback(self, prediction_id: str, actual_result: int):
        """æ”¶é›†é¢„æµ‹åé¦ˆ"""
        # ä¿å­˜åˆ°åé¦ˆæ•°æ®åº“
        await db.save_feedback(prediction_id, actual_result)

    async def retrain_daily(self):
        """æ¯æ—¥å¢é‡è®­ç»ƒ"""
        # 1. è·å–æ˜¨å¤©çš„åé¦ˆæ•°æ®
        feedback_data = await db.get_feedback(date=yesterday)

        # 2. åŠ è½½å½“å‰æ¨¡å‹
        model = load_model('checkpoints/best_model.pt')

        # 3. å¢é‡è®­ç»ƒ
        for epoch in range(5):
            train_step(model, feedback_data)

        # 4. éªŒè¯å¹¶éƒ¨ç½²
        val_acc = evaluate(model, val_data)
        if val_acc > current_acc:
            save_model(model, 'checkpoints/best_model.pt')
            await deploy_model()  # çƒ­æ›´æ–°
```

---

## ğŸ“… å®æ–½æ—¶é—´è¡¨

| é˜¶æ®µ | æ—¶é—´ | å…³é”®é‡Œç¨‹ç¢‘ |
|------|------|-----------|
| **Phase 1** | Month 1-2 | Legacyè¿ç§»å®Œæˆï¼Œæ–°ç³»ç»Ÿä¸Šçº¿ |
| **Phase 2** | Month 2-3 | ç­–ç•¥æ’ä»¶SDKå‘å¸ƒï¼Œç¤¾åŒºç­–ç•¥ä»“åº“ä¸Šçº¿ |
| **Phase 3** | Month 3-4 | åˆ†å¸ƒå¼éƒ¨ç½²ï¼Œ3èŠ‚ç‚¹é›†ç¾¤ç¨³å®šè¿è¡Œ |
| **Phase 4** | Month 4-6 | æ·±åº¦å­¦ä¹ æ¨¡å‹ä¸Šçº¿ï¼Œå‡†ç¡®ç‡æå‡20% |

## ğŸ¯ æˆåŠŸæŒ‡æ ‡

- [ ] ç³»ç»Ÿå“åº”æ—¶é—´ < 50msï¼ˆP99ï¼‰
- [ ] APIå¯ç”¨æ€§ > 99.9%
- [ ] ç¤¾åŒºç­–ç•¥æ•°é‡ > 50ä¸ª
- [ ] å¼‚åŠ¨æ£€æµ‹å‡†ç¡®ç‡ > 85%
- [ ] å¹¶å‘æ”¯æŒ > 1000ç”¨æˆ·
- [ ] æˆæœ¬é™ä½30%ï¼ˆäº‘æœåŠ¡è´¹ç”¨ï¼‰

---

**ä¸‹ä¸€æ­¥è¡ŒåŠ¨ï¼š**
1. åˆ›å»ºAPIç½‘å…³æœåŠ¡
2. è®¾è®¡ç­–ç•¥æ’ä»¶SDK
3. æ­å»ºConsulé›†ç¾¤
4. å‡†å¤‡æ·±åº¦å­¦ä¹ è®­ç»ƒæ•°æ®