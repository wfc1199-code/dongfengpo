# ä¸œé£ç ´é‡åŒ–ç­–ç•¥å¼€å‘é—­ç¯è®¾è®¡æ–¹æ¡ˆ

> **ç‰ˆæœ¬**: v1.0  
> **æ—¥æœŸ**: 2025-01-18  
> **çŠ¶æ€**: è®¾è®¡å®Œæˆï¼Œå¾…å®æ–½

---

## ğŸ“‹ ç›®å½•

1. [é—­ç¯æµç¨‹æ¦‚è§ˆ](#1-é—­ç¯æµç¨‹æ¦‚è§ˆ)
2. [ç­–ç•¥å¼€å‘](#2-ç­–ç•¥å¼€å‘)
3. [å‚æ•°ä¼˜åŒ–](#3-å‚æ•°ä¼˜åŒ–)
4. [å›æµ‹éªŒè¯](#4-å›æµ‹éªŒè¯)
5. [åº”ç”¨åˆ°é€‰è‚¡](#5-åº”ç”¨åˆ°é€‰è‚¡)
6. [æŠ€æœ¯æ¶æ„](#6-æŠ€æœ¯æ¶æ„)
7. [å®æ–½è®¡åˆ’](#7-å®æ–½è®¡åˆ’)

---

## 1. é—­ç¯æµç¨‹æ¦‚è§ˆ

### 1.1 å®Œæ•´æµç¨‹å›¾

```mermaid
graph LR
    A[ç­–ç•¥å¼€å‘] --> B[å‚æ•°ä¼˜åŒ–]
    B --> C[å›æµ‹éªŒè¯]
    C -->|ä¸æ»¡æ„| B
    C -->|æ»¡æ„| D[åº”ç”¨åˆ°é€‰è‚¡]
    D --> E[ç›¯ç›˜é›·è¾¾]
    D --> F[æ˜æ—¥æ½œåŠ›]
    F --> G[ç”¨æˆ·åé¦ˆ]
    G -->|éœ€è¦æ”¹è¿›| A

    style A fill:#e1f5ff
    style B fill:#fff3e0
    style C fill:#f3e5f5
    style D fill:#e8f5e9
    style E fill:#fff9c4
    style F fill:#fff9c4
    style G fill:#fce4ec
```

### 1.2 è®¾è®¡ç†å¿µ

> **ä¸“æ³¨æ™ºèƒ½é€‰è‚¡ï¼Œä¸åšå®ç›˜äº¤æ˜“**

é€šè¿‡å†å²æ•°æ®ä¼˜åŒ–ç­–ç•¥å‚æ•°ï¼Œå°†ç»è¿‡éªŒè¯çš„ç­–ç•¥åº”ç”¨åˆ°"ç›¯ç›˜é›·è¾¾"å’Œ"æ˜æ—¥æ½œåŠ›"åŠŸèƒ½ï¼Œä¸ºç”¨æˆ·æä¾›é«˜è´¨é‡çš„è‚¡ç¥¨ç­›é€‰ç»“æœã€‚

### 1.3 æ ¸å¿ƒä»·å€¼

âœ… **æ•°æ®é©±åŠ¨** - åŸºäºå†å²æ•°æ®ä¼˜åŒ–ï¼Œè€Œéä¸»è§‚åˆ¤æ–­  
âœ… **æŒç»­è¿­ä»£** - å‚æ•°ä¼˜åŒ–å’Œå›æµ‹éªŒè¯å¯åå¤è¿›è¡Œ  
âœ… **é˜²æ­¢è¿‡æ‹Ÿåˆ** - Walk-Forward åˆ†æç¡®ä¿ç­–ç•¥ç¨³å¥æ€§  
âœ… **å¿«é€Ÿåº”ç”¨** - éªŒè¯é€šè¿‡çš„ç­–ç•¥ç«‹å³åº”ç”¨åˆ°ç”Ÿäº§ç¯å¢ƒ

---

## 2. ç­–ç•¥å¼€å‘

### 2.1 ç­–ç•¥ç±»å‹

#### ç›¯ç›˜é›·è¾¾ç­–ç•¥ï¼ˆå®æ—¶ï¼‰

- **ç‚¹ç«ç­–ç•¥**ï¼šæ•æ‰æ€¥é€Ÿæ‹‰å‡
- **æ”¾é‡çªç ´ç­–ç•¥**ï¼šæˆäº¤é‡å¼‚åŠ¨
- **èµ„é‡‘æµå…¥ç­–ç•¥**ï¼šå¤§å•ä¹°å…¥

#### æ˜æ—¥æ½œåŠ›ç­–ç•¥ï¼ˆæ¯æ—¥ï¼‰

- **çªç ´ç­–ç•¥**ï¼šæŠ€æœ¯å½¢æ€çªç ´
- **åŠ¨é‡ç­–ç•¥**ï¼šä»·æ ¼åŠ¨é‡æŒç»­
- **å‡çº¿ç­–ç•¥**ï¼šå¤šå‡çº¿å…±æŒ¯

### 2.2 ç­–ç•¥æ¡†æ¶è®¾è®¡

```python
# shared/strategies/base.py
from abc import ABC, abstractmethod
from typing import Dict, Any, Optional

class BaseStrategy(ABC):
    """ç­–ç•¥åŸºç±»"""

    # å‚æ•°å®šä¹‰ï¼ˆä¾›ä¼˜åŒ–ä½¿ç”¨ï¼‰
    params = {
        'param1': {
            'type': 'float',
            'range': [1.0, 10.0],
            'default': 5.0,
            'description': 'å‚æ•°è¯´æ˜'
        }
    }

    def __init__(self, **kwargs):
        """åˆå§‹åŒ–ç­–ç•¥å‚æ•°"""
        # è®¾ç½®é»˜è®¤å€¼
        for key, value in self.params.items():
            setattr(self, key, value['default'])

        # è¦†ç›–ç”¨æˆ·æä¾›çš„å‚æ•°
        for key, value in kwargs.items():
            if key in self.params:
                setattr(self, key, value)

    @abstractmethod
    def generate_signal(self, data: Dict[str, Any]) -> Optional[Dict]:
        """
        ç”Ÿæˆäº¤æ˜“ä¿¡å·

        Args:
            data: è‚¡ç¥¨æ•°æ®å­—å…¸

        Returns:
            ä¿¡å·å­—å…¸ï¼ŒåŒ…å«action, confidence, reasonç­‰å­—æ®µ
            å¦‚æœä¸äº§ç”Ÿä¿¡å·åˆ™è¿”å›None
        """
        pass

    def get_param_space(self) -> Dict:
        """è·å–å‚æ•°ç©ºé—´ï¼ˆä¾›ä¼˜åŒ–å™¨ä½¿ç”¨ï¼‰"""
        return self.params

    def validate_params(self) -> bool:
        """éªŒè¯å‚æ•°åˆæ³•æ€§"""
        for key, config in self.params.items():
            value = getattr(self, key)
            min_val, max_val = config['range']
            if not (min_val <= value <= max_val):
                return False
        return True
```

### 2.3 ç¤ºä¾‹ç­–ç•¥

```python
# shared/strategies/ignition.py
class IgnitionStrategy(BaseStrategy):
    """ç‚¹ç«ç­–ç•¥ - æ•æ‰æ€¥é€Ÿæ‹‰å‡"""

    params = {
        'rise_threshold': {
            'type': 'float',
            'range': [2.0, 5.0],
            'default': 3.0,
            'description': 'æ¶¨å¹…é˜ˆå€¼(%)'
        },
        'volume_ratio': {
            'type': 'float',
            'range': [1.5, 3.0],
            'default': 2.0,
            'description': 'æˆäº¤é‡å€æ•°'
        },
        'time_window': {
            'type': 'int',
            'range': [3, 10],
            'default': 5,
            'description': 'æ—¶é—´çª—å£(åˆ†é’Ÿ)'
        },
        'min_price': {
            'type': 'float',
            'range': [5.0, 50.0],
            'default': 10.0,
            'description': 'æœ€ä½ä»·æ ¼'
        }
    }

    def generate_signal(self, data: Dict[str, Any]) -> Optional[Dict]:
        """æ£€æµ‹æ€¥é€Ÿæ‹‰å‡ä¿¡å·"""
        # ä»·æ ¼è¿‡æ»¤
        if data['current_price'] < self.min_price:
            return None

        # è®¡ç®—æ¶¨å¹…
        rise = (data['current_price'] - data['open']) / data['open'] * 100

        # è®¡ç®—æˆäº¤é‡æ¯”
        vol_ratio = data['volume'] / data['avg_volume_5d']

        # åˆ¤æ–­ä¿¡å·
        if rise >= self.rise_threshold and vol_ratio >= self.volume_ratio:
            confidence = min(rise / 10 * 100, 100)  # æ¶¨å¹…è¶Šå¤§ä¿¡å¿ƒè¶Šè¶³

            return {
                'action': 'BUY',
                'confidence': confidence,
                'reason': f'æ€¥é€Ÿæ‹‰å‡{rise:.2f}%ï¼Œæˆäº¤é‡{vol_ratio:.2f}å€',
                'detail': {
                    'rise': rise,
                    'volume_ratio': vol_ratio,
                    'price': data['current_price']
                }
            }

        return None
```

---

## 3. å‚æ•°ä¼˜åŒ–

### 3.1 ä¼˜åŒ–ç®—æ³•å¯¹æ¯”

| ç®—æ³•       | é€‚ç”¨åœºæ™¯   | ä¼˜ç‚¹       | ç¼ºç‚¹         | æ¨èåº¦     |
| ---------- | ---------- | ---------- | ------------ | ---------- |
| ç½‘æ ¼æœç´¢   | å‚æ•° â‰¤3 ä¸ª | è¯¦å°½ã€å¯é  | æ…¢           | â­â­â­     |
| éšæœºæœç´¢   | å‚æ•°>3 ä¸ª  | å¿«é€Ÿ       | å¯èƒ½é—æ¼æœ€ä¼˜ | â­â­â­â­   |
| é—ä¼ ç®—æ³•   | å¤æ‚ç­–ç•¥   | æ™ºèƒ½ã€é«˜æ•ˆ | éœ€è¦è°ƒå‚     | â­â­â­â­â­ |
| è´å¶æ–¯ä¼˜åŒ– | é«˜çº§åº”ç”¨   | æ ·æœ¬é«˜æ•ˆ   | å®ç°å¤æ‚     | â­â­â­     |

### 3.2 é—ä¼ ç®—æ³•å®ç°ï¼ˆæ¨èï¼‰

```python
# services/backtest-engine/core/optimizer.py
import numpy as np
from typing import Dict, List, Callable

class GeneticOptimizer:
    """é—ä¼ ç®—æ³•å‚æ•°ä¼˜åŒ–å™¨"""

    def __init__(
        self,
        strategy_class,
        param_space: Dict,
        objective_fn: Callable,
        population_size: int = 50,
        generations: int = 30,
        mutation_rate: float = 0.1,
        crossover_rate: float = 0.8
    ):
        self.strategy_class = strategy_class
        self.param_space = param_space
        self.objective_fn = objective_fn
        self.population_size = population_size
        self.generations = generations
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate

    def optimize(self) -> Dict:
        """æ‰§è¡Œä¼˜åŒ–"""
        # åˆå§‹åŒ–ç§ç¾¤
        population = self._init_population()

        best_history = []

        for gen in range(self.generations):
            # è¯„ä¼°é€‚åº”åº¦
            fitness_scores = self._evaluate_population(population)

            # è®°å½•æœ€ä¼˜ä¸ªä½“
            best_idx = np.argmax(fitness_scores)
            best_params = population[best_idx]
            best_score = fitness_scores[best_idx]

            best_history.append({
                'generation': gen,
                'params': best_params.copy(),
                'score': best_score
            })

            print(f"Generation {gen+1}/{self.generations}: "
                  f"Best Score = {best_score:.4f}")

            # é€‰æ‹©
            selected = self._selection(population, fitness_scores)

            # äº¤å‰
            offspring = self._crossover(selected)

            # å˜å¼‚
            offspring = self._mutation(offspring)

            # æ›´æ–°ç§ç¾¤
            population = offspring

        return {
            'best_params': best_history[-1]['params'],
            'best_score': best_history[-1]['score'],
            'history': best_history
        }

    def _init_population(self) -> List[Dict]:
        """åˆå§‹åŒ–ç§ç¾¤"""
        population = []
        for _ in range(self.population_size):
            individual = {}
            for param_name, param_config in self.param_space.items():
                min_val, max_val = param_config['range']
                param_type = param_config['type']

                if param_type == 'float':
                    individual[param_name] = np.random.uniform(min_val, max_val)
                elif param_type == 'int':
                    individual[param_name] = np.random.randint(min_val, max_val + 1)

            population.append(individual)

        return population

    def _evaluate_population(self, population: List[Dict]) -> np.ndarray:
        """è¯„ä¼°ç§ç¾¤é€‚åº”åº¦"""
        scores = []
        for params in population:
            score = self.objective_fn(params)
            scores.append(score)
        return np.array(scores)

    def _selection(self, population: List[Dict], fitness: np.ndarray) -> List[Dict]:
        """è½®ç›˜èµŒé€‰æ‹©"""
        # å½’ä¸€åŒ–é€‚åº”åº¦
        fitness = fitness - fitness.min() + 1e-6
        probabilities = fitness / fitness.sum()

        # é€‰æ‹©
        selected_indices = np.random.choice(
            len(population),
            size=self.population_size,
            p=probabilities,
            replace=True
        )

        return [population[i].copy() for i in selected_indices]

    def _crossover(self, population: List[Dict]) -> List[Dict]:
        """å•ç‚¹äº¤å‰"""
        offspring = []
        for i in range(0, len(population), 2):
            parent1 = population[i]
            parent2 = population[i + 1] if i + 1 < len(population) else population[0]

            if np.random.rand() < self.crossover_rate:
                # äº¤å‰
                child1, child2 = {}, {}
                params = list(parent1.keys())
                crossover_point = np.random.randint(1, len(params))

                for j, param in enumerate(params):
                    if j < crossover_point:
                        child1[param] = parent1[param]
                        child2[param] = parent2[param]
                    else:
                        child1[param] = parent2[param]
                        child2[param] = parent1[param]

                offspring.extend([child1, child2])
            else:
                offspring.extend([parent1.copy(), parent2.copy()])

        return offspring[:self.population_size]

    def _mutation(self, population: List[Dict]) -> List[Dict]:
        """å˜å¼‚"""
        for individual in population:
            if np.random.rand() < self.mutation_rate:
                # éšæœºé€‰æ‹©ä¸€ä¸ªå‚æ•°å˜å¼‚
                param_name = np.random.choice(list(individual.keys()))
                param_config = self.param_space[param_name]
                min_val, max_val = param_config['range']
                param_type = param_config['type']

                if param_type == 'float':
                    individual[param_name] = np.random.uniform(min_val, max_val)
                elif param_type == 'int':
                    individual[param_name] = np.random.randint(min_val, max_val + 1)

        return population
```

### 3.3 Walk-Forward åˆ†æï¼ˆé˜²è¿‡æ‹Ÿåˆï¼‰

```python
def walk_forward_analysis(
    strategy_class,
    data,
    param_space,
    train_months=12,
    test_months=3
):
    """
    æ»šåŠ¨çª—å£åˆ†æ

    Args:
        strategy_class: ç­–ç•¥ç±»
        data: å®Œæ•´å†å²æ•°æ®
        param_space: å‚æ•°ç©ºé—´
        train_months: è®­ç»ƒæœŸé•¿åº¦ï¼ˆæœˆï¼‰
        test_months: æµ‹è¯•æœŸé•¿åº¦ï¼ˆæœˆï¼‰
    """
    train_days = train_months * 21
    test_days = test_months * 21

    results = []

    for start in range(0, len(data) - train_days - test_days, test_days):
        # è®­ç»ƒæœŸ
        train_data = data[start:start + train_days]

        # ä¼˜åŒ–å‚æ•°
        optimizer = GeneticOptimizer(strategy_class, param_space, ...)
        best_params = optimizer.optimize()['best_params']

        # æµ‹è¯•æœŸ
        test_data = data[start + train_days:start + train_days + test_days]

        # åœ¨æµ‹è¯•æœŸéªŒè¯
        test_result = backtest(strategy_class, test_data, best_params)

        results.append({
            'period': f'{start}-{start + train_days + test_days}',
            'params': best_params,
            'test_metrics': test_result.metrics
        })

    return results
```

---

## 4. å›æµ‹éªŒè¯

### 4.1 éªŒè¯æŒ‡æ ‡

**å¿…é¡»è¾¾æ ‡**ï¼š

- âœ… å¹´åŒ–æ”¶ç›Šç‡ > 15%
- âœ… æœ€å¤§å›æ’¤ < 20%
- âœ… å¤æ™®æ¯”ç‡ > 1.0
- âœ… èƒœç‡ > 55%

**å‚è€ƒæŒ‡æ ‡**ï¼š

- ç›ˆäºæ¯” > 1.5
- ç´¢æè¯ºæ¯”ç‡ > 1.0
- å¡ç›æ¯”ç‡ > 0.5

### 4.2 å›æµ‹æŠ¥å‘Šæ¨¡æ¿

````markdown
# å›æµ‹æŠ¥å‘Š - ç‚¹ç«ç­–ç•¥ v2.0

## åŸºæœ¬ä¿¡æ¯

- ç­–ç•¥: IgnitionStrategy
- ç‰ˆæœ¬: 2.0
- ä¼˜åŒ–æ–¹æ³•: é—ä¼ ç®—æ³•(50 ä»£)
- å›æµ‹æœŸ: 2023-01-01 ~ 2024-12-31
- åˆå§‹èµ„é‡‘: Â¥100,000

## æ€§èƒ½æŒ‡æ ‡

| æŒ‡æ ‡       | æ•°å€¼   | ç›®æ ‡ | çŠ¶æ€ |
| ---------- | ------ | ---- | ---- |
| å¹´åŒ–æ”¶ç›Šç‡ | 28.5%  | >15% | âœ…   |
| æœ€å¤§å›æ’¤   | -12.3% | <20% | âœ…   |
| å¤æ™®æ¯”ç‡   | 1.68   | >1.0 | âœ…   |
| èƒœç‡       | 63.2%  | >55% | âœ…   |

## æœ€ä¼˜å‚æ•°

```python
{
    'rise_threshold': 3.2,
    'volume_ratio': 2.4,
    'time_window': 5,
    'min_price': 12.0
}
```
````

## Walk-Forward åˆ†æ

æ ·æœ¬å¤–æ€§èƒ½è¡°å‡: 4.5% (å¯æ¥å—)

## ç»“è®º

âœ… ç­–ç•¥é€šè¿‡éªŒè¯ï¼Œå»ºè®®ä¸Šçº¿

````

---

## 5. åº”ç”¨åˆ°é€‰è‚¡

### 5.1 é›†æˆåˆ°ç›¯ç›˜é›·è¾¾

```python
# services/signal-api/core/quant/engines/radar.py
from shared.strategies.ignition import IgnitionStrategy

class RadarEngine:
    def __init__(self):
        # ä½¿ç”¨ä¼˜åŒ–åçš„å‚æ•°
        self.strategies = {
            'ignition': IgnitionStrategy(
                rise_threshold=3.2,
                volume_ratio=2.4,
                time_window=5,
                min_price=12.0
            )
        }

    async def scan_market(self):
        """æ‰«æå¸‚åœºå¼‚åŠ¨"""
        stocks = await self.get_active_stocks()
        signals = []

        for stock in stocks:
            data = await self.get_realtime_data(stock['code'])

            # åº”ç”¨ç­–ç•¥
            for strategy_name, strategy in self.strategies.items():
                signal = strategy.generate_signal(data)
                if signal:
                    signals.append({
                        'code': stock['code'],
                        'name': stock['name'],
                        'strategy': strategy_name,
                        'signal': signal
                    })

        return signals
````

### 5.2 é›†æˆåˆ°æ˜æ—¥æ½œåŠ›

```python
# services/signal-api/core/quant/engines/tomorrow.py
class TomorrowPredictor:
    def __init__(self):
        # å¤šç­–ç•¥ç»„åˆ
        self.strategies = [
            TomorrowPotentialStrategy(...),
            BreakthroughStrategy(...),
            MomentumStrategy(...)
        ]

    async def predict(self):
        """é¢„æµ‹æ˜æ—¥æ½œåŠ›è‚¡"""
        stocks = await self.get_all_stocks()
        predictions = []

        for stock in stocks:
            data = await self.get_daily_data(stock['code'])

            # å¤šç­–ç•¥æŠ•ç¥¨
            votes = []
            for strategy in self.strategies:
                signal = strategy.generate_signal(data)
                if signal:
                    votes.append(signal)

            # 2ä¸ªä»¥ä¸Šç­–ç•¥çœ‹å¥½æ‰æ¨è
            if len(votes) >= 2:
                predictions.append({
                    'code': stock['code'],
                    'name': stock['name'],
                    'confidence': len(votes) * 30,
                    'strategies': [s.__class__.__name__ for s in self.strategies]
                })

        return sorted(predictions, key=lambda x: x['confidence'], reverse=True)[:50]
```

---

## 6. æŠ€æœ¯æ¶æ„

### 6.1 é¡¹ç›®ç»“æ„

```
ä¸œé£ç ´/
â”œâ”€â”€ services/
â”‚   â”œâ”€â”€ backtest-engine/          # å›æµ‹ä¼˜åŒ–æœåŠ¡
â”‚   â”‚   â”œâ”€â”€ core/
â”‚   â”‚   â”‚   â”œâ”€â”€ executor.py       # å›æµ‹æ‰§è¡Œå™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ optimizer.py      # å‚æ•°ä¼˜åŒ–å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ analyzer.py       # æ€§èƒ½åˆ†æ
â”‚   â”‚   â”‚   â””â”€â”€ reporter.py       # æŠ¥å‘Šç”Ÿæˆ
â”‚   â”‚   â””â”€â”€ routers/
â”‚   â”‚       â”œâ”€â”€ backtest.py
â”‚   â”‚       â””â”€â”€ optimize.py
â”‚   â”‚
â”‚   â”œâ”€â”€ signal-api/
â”‚   â”‚   â””â”€â”€ core/quant/engines/
â”‚   â”‚       â”œâ”€â”€ radar.py          # ç›¯ç›˜é›·è¾¾
â”‚   â”‚       â””â”€â”€ tomorrow.py       # æ˜æ—¥æ½œåŠ›
â”‚   â”‚
â”œâ”€â”€ shared/                       # å…±äº«æ¨¡å—
â”‚   â”œâ”€â”€ strategies/               # ç­–ç•¥åº“
â”‚   â”‚   â”œâ”€â”€ base.py
â”‚   â”‚   â”œâ”€â”€ ignition.py
â”‚   â”‚   â””â”€â”€ tomorrow_potential.py
â”‚   â”œâ”€â”€ indicators/
â”‚   â””â”€â”€ models/
â”‚
â””â”€â”€ frontend/
    â””â”€â”€ src/pages/
        â”œâ”€â”€ Backtest/
        â”œâ”€â”€ Optimization/
        â””â”€â”€ StrategyManagement/
```

### 6.2 API è®¾è®¡

```
POST /api/optimize/run           # è¿è¡Œå‚æ•°ä¼˜åŒ–
GET  /api/optimize/tasks/{id}    # æŸ¥è¯¢ä¼˜åŒ–çŠ¶æ€
GET  /api/optimize/results/{id}  # è·å–ä¼˜åŒ–ç»“æœ

POST /api/backtest/run           # è¿è¡Œå›æµ‹
GET  /api/backtest/results/{id}  # è·å–å›æµ‹ç»“æœ

POST /api/strategy/deploy        # éƒ¨ç½²ç­–ç•¥åˆ°ç”Ÿäº§
GET  /api/strategy/list          # è·å–ç­–ç•¥åˆ—è¡¨
```

---

## 7. å®æ–½è®¡åˆ’

### Phase 1: å›æµ‹åŸºç¡€ï¼ˆ2 å‘¨ï¼‰

- [x] å›æµ‹å¼•æ“å¼€å‘
- [ ] åŸºæœ¬æŒ‡æ ‡è®¡ç®—
- [ ] å‰ç«¯å›æµ‹é¡µé¢

### Phase 2: å‚æ•°ä¼˜åŒ–ï¼ˆ2 å‘¨ï¼‰â¬…ï¸ å½“å‰é‡ç‚¹

- [ ] ç½‘æ ¼æœç´¢
- [ ] é—ä¼ ç®—æ³•
- [ ] Walk-Forward åˆ†æ
- [ ] å‰ç«¯ä¼˜åŒ–é¡µé¢

### Phase 3: ç­–ç•¥é›†æˆï¼ˆ1 å‘¨ï¼‰

- [ ] ç­–ç•¥è¿ç§»åˆ° shared/
- [ ] ç›¯ç›˜é›·è¾¾é›†æˆ
- [ ] æ˜æ—¥æ½œåŠ›é›†æˆ

### Phase 4: æŒç»­è¿­ä»£

- [ ] æ”¶é›†åé¦ˆ
- [ ] ä¼˜åŒ–ç­–ç•¥
- [ ] å¼€å‘æ–°ç­–ç•¥

---

**æ–‡æ¡£ç‰ˆæœ¬**: v1.0  
**åˆ›å»ºæ—¥æœŸ**: 2025-01-18  
**ç»´æŠ¤è€…**: å¼€å‘å›¢é˜Ÿ
