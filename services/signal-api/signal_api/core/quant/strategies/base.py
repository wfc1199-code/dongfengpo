"""
AI Quant Platform - Base Strategy
Abstract base class for all trading strategies.

Features:
- Unified interface for strategy implementation
- Signal generation with confidence scoring
- Parameter validation and configuration
"""

from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional, Any
from enum import Enum
import pandas as pd
import logging

logger = logging.getLogger(__name__)


class SignalType(Enum):
    """Trading signal types."""
    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class Signal:
    """
    Trading signal generated by a strategy.
    
    Attributes:
        symbol: Stock symbol
        signal_type: BUY, SELL, or HOLD
        confidence: Confidence score (0.0 - 1.0)
        price: Current price at signal generation
        timestamp: When the signal was generated
        reason: Human-readable explanation
        factors: Dict of factor values that contributed to the signal
    """
    symbol: str
    signal_type: SignalType
    confidence: float
    price: float
    timestamp: datetime
    reason: str = ""
    factors: Dict[str, float] = field(default_factory=dict)
    
    def __post_init__(self):
        """Validate confidence is within bounds."""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError(f"Confidence must be between 0 and 1, got {self.confidence}")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization."""
        return {
            "symbol": self.symbol,
            "signal_type": self.signal_type.value,
            "confidence": self.confidence,
            "price": self.price,
            "timestamp": self.timestamp.isoformat(),
            "reason": self.reason,
            "factors": self.factors
        }


@dataclass
class StrategyConfig:
    """
    Base configuration for strategies.
    
    Subclasses should extend this with strategy-specific parameters.
    """
    name: str = "BaseStrategy"
    min_confidence: float = 0.6  # Minimum confidence to generate a signal
    lookback_days: int = 30  # Days of historical data needed
    
    def validate(self) -> None:
        """Validate configuration parameters."""
        if not 0.0 <= self.min_confidence <= 1.0:
            raise ValueError(f"min_confidence must be between 0 and 1, got {self.min_confidence}")
        if self.lookback_days < 1:
            raise ValueError(f"lookback_days must be >= 1, got {self.lookback_days}")


class BaseStrategy(ABC):
    """
    Abstract base class for trading strategies.
    
    All strategies must implement:
    1. calculate_factors() - Compute technical indicators
    2. generate_signal() - Generate trading signals
    
    Lifecycle:
    1. Strategy is initialized with configuration
    2. set_data() is called with historical price data
    3. calculate_factors() computes all indicators
    4. generate_signal() is called for each bar/tick
    """
    
    def __init__(self, config: Optional[StrategyConfig] = None):
        """
        Initialize the strategy.
        
        Args:
            config: Strategy configuration. Uses default if not provided.
        """
        self.config = config or StrategyConfig()
        self.config.validate()
        
        self._data: Optional[pd.DataFrame] = None
        self._factors: Optional[pd.DataFrame] = None
        self._is_initialized: bool = False
        
        logger.info(f"Strategy '{self.config.name}' initialized")
    
    @property
    def name(self) -> str:
        """Strategy name."""
        return self.config.name
    
    @property
    def is_ready(self) -> bool:
        """Check if strategy has data and is ready to generate signals."""
        return self._is_initialized and self._data is not None
    
    def set_data(self, df: pd.DataFrame) -> None:
        """
        Set historical price data for the strategy.
        
        Args:
            df: DataFrame with columns ['datetime', 'open', 'high', 'low', 'close', 'volume', 'amount']
        
        Raises:
            ValueError: If required columns are missing.
        """
        required_cols = ['datetime', 'open', 'high', 'low', 'close', 'volume']
        missing = set(required_cols) - set(df.columns)
        if missing:
            raise ValueError(f"Missing required columns: {missing}")
        
        self._data = df.copy()
        self._data = self._data.sort_values('datetime').reset_index(drop=True)
        
        # Calculate factors
        self._factors = self.calculate_factors(self._data)
        self._is_initialized = True
        
        logger.info(f"Strategy '{self.name}' loaded {len(df)} bars")
    
    @abstractmethod
    def calculate_factors(self, df: pd.DataFrame) -> pd.DataFrame:
        """
        Calculate all technical factors/indicators.
        
        Args:
            df: DataFrame with OHLCV data
        
        Returns:
            DataFrame with original columns plus factor columns
        """
        pass
    
    @abstractmethod
    def generate_signal(self, index: int) -> Optional[Signal]:
        """
        Generate a trading signal for a specific bar.
        
        Args:
            index: Index into the data DataFrame
        
        Returns:
            Signal if conditions are met, None otherwise
        """
        pass
    
    def scan(self) -> List[Signal]:
        """
        Scan all bars and collect signals.
        
        Returns:
            List of all generated signals
        """
        if not self.is_ready:
            raise RuntimeError("Strategy not initialized. Call set_data() first.")
        
        signals = []
        for i in range(len(self._data)):
            signal = self.generate_signal(i)
            if signal and signal.confidence >= self.config.min_confidence:
                signals.append(signal)
        
        logger.info(f"Strategy '{self.name}' generated {len(signals)} signals")
        return signals
    
    def get_latest_signal(self) -> Optional[Signal]:
        """
        Get signal for the most recent bar.
        
        Returns:
            Signal if conditions are met, None otherwise
        """
        if not self.is_ready:
            return None
        
        return self.generate_signal(len(self._data) - 1)
    
    def get_factors_df(self) -> Optional[pd.DataFrame]:
        """Get the calculated factors DataFrame."""
        return self._factors
