<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TDX æ”¯æ’‘å‹åŠ›ç®—æ³•éªŒè¯</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/echarts/5.4.3/echarts.min.js"></script>
    <style>
        body { font-family: sans-serif; padding: 20px; background: #f0f2f5; }
        .container { max-width: 1200px; margin: 0 auto; background: white; padding: 20px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); }
        .controls { margin-bottom: 20px; display: flex; gap: 10px; flex-wrap: wrap; }
        button { padding: 8px 16px; cursor: pointer; border: 1px solid #ccc; background: #fff; border-radius: 4px; }
        button:hover { background: #f0f0f0; }
        button.primary { background: #1890ff; color: white; border: none; }
        button.primary:hover { background: #40a9ff; }
        #chart { width: 100%; height: 600px; border: 1px solid #eee; }
        .log-panel { margin-top: 20px; padding: 10px; background: #1e1e1e; color: #0f0; font-family: monospace; height: 150px; overflow-y: auto; border-radius: 4px; }
    </style>
</head>
<body>
    <div class="container">
        <h1>TDX æ”¯æ’‘å‹åŠ›ç®—æ³•éªŒè¯å·¥ä½œå°</h1>

        <div class="controls">
            <button onclick="generateData('range')">ç”Ÿæˆéœ‡è¡å½¢æ€ (Box)</button>
            <button onclick="generateData('uptrend')">ç”Ÿæˆä¸Šå‡è¶‹åŠ¿</button>
            <button onclick="generateData('m_pattern')">ç”Ÿæˆ M å¤´å½¢æ€</button>
            <div style="width: 20px;"></div>
            <button class="primary" onclick="calculateSR()">ğŸš€ è®¡ç®—æ”¯æ’‘å‹åŠ›</button>
            <button onclick="clearLines()">æ¸…é™¤çº¿æ¡</button>
        </div>

        <div id="chart"></div>
        <div id="logs" class="log-panel">ç³»ç»Ÿå‡†å¤‡å°±ç»ª...</div>
    </div>

    <script>
        let chart = echarts.init(document.getElementById('chart'));
        let currentData = null;

        // åˆå§‹åŒ–å›¾è¡¨
        function initChart(data) {
            const option = {
                tooltip: {
                    trigger: 'axis',
                    axisPointer: { type: 'cross' }
                },
                grid: { left: '3%', right: '10%', bottom: '15%' },
                xAxis: {
                    type: 'category',
                    data: data.dates,
                    scale: true,
                    boundaryGap: false,
                    axisLine: { onZero: false },
                    splitLine: { show: false },
                    min: 'dataMin',
                    max: 'dataMax'
                },
                yAxis: {
                    scale: true,
                    splitArea: { show: true }
                },
                dataZoom: [
                    { type: 'inside', start: 0, end: 100 },
                    { show: true, type: 'slider', top: '90%' }
                ],
                series: [
                    {
                        name: 'Kçº¿',
                        type: 'candlestick',
                        data: data.values,
                        itemStyle: {
                            color: '#ef4444',
                            color0: '#10b981',
                            borderColor: '#ef4444',
                            borderColor0: '#10b981'
                        }
                    }
                ]
            };
            chart.setOption(option);
            currentData = data;
            log(`å·²ç”Ÿæˆ ${data.values.length} æ ¹Kçº¿æ•°æ®`);
        }

        // ç”Ÿæˆæ¨¡æ‹Ÿæ•°æ®
        function generateData(type) {
            let basePrice = 100;
            let prices = [];
            let dates = [];
            let volatility = 2;

            for (let i = 0; i < 100; i++) {
                let change = (Math.random() - 0.5) * volatility;

                if (type === 'uptrend') change += 0.5;
                if (type === 'range') {
                    // å¼ºè¡Œæ‹‰å› 100
                    if (basePrice > 110) change -= 1;
                    if (basePrice < 90) change += 1;
                }
                if (type === 'm_pattern') {
                    // 0-30 ä¸Šæ¶¨, 30-50 ä¸‹è·Œ, 50-70 ä¸Šæ¶¨, 70-100 ä¸‹è·Œ
                    if (i < 30) change += 0.8;
                    else if (i < 50) change -= 0.8;
                    else if (i < 70) change += 0.8;
                    else change -= 0.8;
                }

                basePrice += change;

                let open = basePrice + (Math.random() - 0.5);
                let close = basePrice + (Math.random() - 0.5);
                let high = Math.max(open, close) + Math.random();
                let low = Math.min(open, close) - Math.random();

                prices.push([open, close, low, high]);
                dates.push(i);
            }

            initChart({ dates, values: prices });
            clearLines();
        }

        // è°ƒç”¨ API è®¡ç®—
        async function calculateSR() {
            if (!currentData) return alert('è¯·å…ˆç”Ÿæˆæ•°æ®');

            log('æ­£åœ¨è¯·æ±‚ API: http://localhost:9001/support-resistance/tdx/calculate ...');

            // æ„é€  Payload
            const payload = {
                symbol: "TEST",
                prices: currentData.values.map(k => k[1]), // close
                highs: currentData.values.map(k => k[3]),
                lows: currentData.values.map(k => k[2]),
                volumes: currentData.values.map(() => 1000 + Math.random() * 1000), // Mock volume
                prev_close: currentData.values[0][1] * 0.98,
                today_open: currentData.values[currentData.values.length-1][0]
            };

            try {
                const res = await fetch('http://localhost:9001/support-resistance/tdx/calculate', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                const data = await res.json();

                if (data.success) {
                    log(`è®¡ç®—æˆåŠŸ! å‘ç° ${data.levels.length} æ¡çº¿`);
                    log(`åˆ†æ: ${data.analysis.summary}`);
                    drawLevels(data.levels);
                } else {
                    log('è®¡ç®—å¤±è´¥: ' + JSON.stringify(data));
                }

            } catch (e) {
                log('è¯·æ±‚é”™è¯¯ (ç¡®ä¿åå°æœåŠ¡å·²å¯åŠ¨): ' + e.message);
            }
        }

        function drawLevels(levels) {
            const markLines = levels.map(level => ({
                yAxis: level.price,
                label: {
                    formatter: `${level.type === 'resistance' ? 'å‹åŠ›' : 'æ”¯æ’‘'} ${level.price}\nS:${level.strength}`,
                    position: 'end',
                    color: level.visual_style.color
                },
                lineStyle: {
                    color: level.visual_style.color,
                    type: level.visual_style.lineStyle || 'solid',
                    width: level.visual_style.lineWidth || 1,
                    opacity: level.visual_style.opacity || 0.8
                }
            }));

            chart.setOption({
                series: [{
                    markLine: {
                        symbol: ['none', 'none'],
                        data: markLines,
                        animation: false
                    }
                }]
            });
        }

        function clearLines() {
            chart.setOption({ series: [{ markLine: { data: [] } }] });
            log('çº¿æ¡å·²æ¸…é™¤');
        }

        function log(msg) {
            const el = document.getElementById('logs');
            el.innerHTML += `<div>[${new Date().toLocaleTimeString()}] ${msg}</div>`;
            el.scrollTop = el.scrollHeight;
        }

        // é»˜è®¤ç”Ÿæˆä¸€ç»„æ•°æ®
        generateData('range');
    </script>
</body>
</html>
